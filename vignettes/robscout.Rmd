---
title: "robscout: WORK IN PROGRESS"
output: 
  rmarkdown::html_vignette:
    toc: true 
vignette: >
  %\VignetteIndexEntry{robscout}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
  \usepackage{amsmath}
  \DeclareMathOperator{\Tr}{Tr}
---

This vignette documents the changes that are made in `robscout` when compared to `scout`.

# Implementation details 

From the scout: 

**Step 1** is to compute ${\hat{\Theta}}_{XX}$ maximizing 
$$
\log{\det(\Theta_{XX})} - \Tr(S_{XX}\Theta_{XX}) - \lambda_1 \left\Vert \Theta_{XX} \right\Vert^{p_1}
$$
**Step 2** is to compute ${\hat{\Theta}}$ maximizing 
$$
\log{\det(\Theta)} - \Tr(S\Theta) - \lambda_1 \left\Vert \Theta \right\Vert^{p_1}
$$
subject to: top-left $p \times p$ block of $\hat{\Theta}$ is set to $\hat{\Theta}_{XX}$ from Step 1. 

In code, this translates to: 
```
sigma_xx = est_cov(X)            # this should return some robust estimate of cov(X)
theta_xx = est_inv_cov(sigma_xx) # assuming a robust plug-in strategy
sigma_xy = est_cov(X, Y)         # this should return some robust estimate of cov(X, Y)
betas = scout::crossProdLasso(solve(theta_xx), sigma_xy) 
```

In the last line of code, we pass $\hat{\Theta}_{XX}^{-1}$ as the covariance estimate into the `scout::crossProdLasso` function, which returns the coefficients. Also note that `scout::crossProdLasso` requires a positive semi-definite $\hat{\Theta}_{XX}^{-1}$; otherwise it will not converge.

Scout should take the following arguments:

- cov_xx_method: method to estiamte the precision matrix of X. 
  - glasso (p1 = 1)
  - gridge (p1 = 2)
  - ddc_di (p1 = 1, DI algorithm with DDC as the initial estimator)
  - rob_glasso (robust graphical lasso based on MV winsorization)
  - ddc_glasso (imputation with ddc on c(X,Y), then estimate cov on that matrix and grab the XX block)
- cov_xy_method:
  - default (uses the `cov` function)
  - ddc (imputation with ddc on c(X,Y), then estimate cov on that matrix and grab the XY block)
- beta_method: method to estimate coefficients 
  - lasso_one: p1 = 1
  - none: p1 = NULL (no regularization)


pseudocode for a workflow 

```{r, eval = FALSE}
robscout <- function(X, Y, cov_xx_method = "glasso", cov_xy_method = "default", beta_method = "lasso", opt_method = "stepwise") {

}

robscout_stepwise <- function(X, Y, cov_xx_method, cov_xy_method, beta_method) {
  Sigma_XX <- est_cov(X, NULL, cov_xx_method)
  Sigma_XY <- est_cov(X, Y, cov_xx_method)
  coefs <- robscout_beta_cv(Sigma_XX, Sigma_XY, beta_method)
}

robscout_beta_cv <- function(Sigma_XX, Sigma_XY, beta_method) {

}
```

# `huge` examples

The goal of this short experiment is to 
```{r libraries}
library(cellWise)
library(huge)
```

```{r datagen}
set.seed(2024)
data <- robscoutSim::generate("make_data_setting1", n = 100)

# clean data
X <- data$X
X_std <- scale(X)
n <- nrow(X)
```

```{r fit-glasso, message = F, warning = F}
get_glasso_errors <- function(hg_out, cov_est, n, method = c("loglik", "bic", "ebic")) {
  unlist(lapply(hg_out$icov, function(icov) {
    scout::icov_error(icov, cov_est, n, method = "loglik")
  }))
}
best_glasso_idx <- function(hg_out, cov_est, n, method = c("loglik", "big")) {
  errors <- get_glasso_errors(hg_out, cov_est, n, method)
  which.min(errors)
}

# hg_out: output of running huge with "glasso"
# n: number of observations
# d: number of features
# ebic.gamma: tuning param, default is 0.5
compute_ebic <- function(hg_out, n, d, ebic.gamma = 0.5) {
  -n * hg_out$loglik + log(n) * hg_out$df + 4 * ebic.gamma * log(d) * hg_out$df
}

# Default covariance estimation
cov_x_default <- cov(X_std)
hg_default <- huge(cov_x_default, nlambda = 100, method = "glasso", verbose = FALSE, cov.output = TRUE)
best_idx_default <- best_glasso_idx(hg_default, cov_x_default, n, "bic")
icov_default <- hg_default$icov[[best_idx_default]]
cov_default <- hg_default$cov[[best_idx_default]]

plt <- plot(hg_default, align = TRUE)

# Estimate the covariance matrix using DI
di_x <- DI(X_std, checkPars = list(silent = TRUE))
cov_x_di <- di_x$cov
hg_di <- huge(cov_x_di, nlambda = 100, method = "glasso", verbose = FALSE, cov.output = TRUE)
best_idx_di <- best_glasso_idx(hg_di, cov_x_di, n, "bic")
icov_di <- hg_di$icov[[best_idx_di]]
cov_di <- hg_di$cov[[best_idx_di]]

# Plot of true precision matrix structure
true_prec_mat <- solve(data$cov_x)
huge.plot(true_prec_mat)

# Plot of estimated precision matrix w/ with default covariance matrix
huge.plot(icov_default)

# Plot of estimated precision matrix w/ DI covariance matrix
huge.plot(icov_di)
```


`in hugeglasso.cpp`
- `d` = nfeatures = p
